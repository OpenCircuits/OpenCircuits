"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[970],{1226:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"Other/DesignDocs/CircuitToExpression","title":"Circuit to Logical Expression","description":"---","source":"@site/../../../../docs/Other/DesignDocs/CircuitToExpression.md","sourceDirName":"Other/DesignDocs","slug":"/Other/DesignDocs/CircuitToExpression","permalink":"/Other/DesignDocs/CircuitToExpression","draft":false,"unlisted":false,"editUrl":"https://github.com/OpenCircuits/OpenCircuits/edit/master/docs/Other/DesignDocs/CircuitToExpression.md","tags":[],"version":"current","frontMatter":{"title":"Circuit to Logical Expression"},"sidebar":"otherSidebar","previous":{"title":"GCP Datastore Setup","permalink":"/Other/References/GCPDatastoreSetup"},"next":{"title":"Logical Expression to Circuit","permalink":"/Other/DesignDocs/ExpressionToCircuit"}}');var o=t(2295),s=t(8002),l=t(6663),r=t(1782);const a={title:"Circuit to Logical Expression"},c=void 0,d={},h=[{value:"<em>Trevor Crystal</em>, <em>Leon Montealegre</em> (Last updated <em>June 19, 2022</em>)",id:"trevor-crystal-leon-montealegre-last-updated-june-19-2022",level:4},{value:"Overview",id:"overview",level:2},{value:"Context",id:"context",level:2},{value:"Goals &amp; Non-Goals",id:"goals--non-goals",level:2},{value:"Goals:",id:"goals",level:3},{value:"Non-Goals:",id:"non-goals",level:3},{value:"Milestones",id:"milestones",level:2},{value:"Existing Solution",id:"existing-solution",level:2},{value:"Proposed Solution",id:"proposed-solution",level:2},{value:"Alternative Solutions",id:"alternative-solutions",level:2},{value:"Testability",id:"testability",level:2},{value:"Impact",id:"impact",level:2},{value:"Known Unknowns",id:"known-unknowns",level:2},{value:"Detailed Scoping",id:"detailed-scoping",level:2},{value:"Milestone 1",id:"milestone-1",level:3},{value:"Milestone 2",id:"milestone-2",level:3},{value:"Milestone 3",id:"milestone-3",level:3}];function u(e){const n={a:"a",code:"code",del:"del",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",ul:"ul",...(0,s.R)(),...e.components},{Details:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)("div",{style:{height:"80px",width:"100%"},children:(0,o.jsx)("img",{src:"/img/icon.svg",width:"80px",style:{float:"right"}})}),"\n",(0,o.jsxs)(n.h1,{id:"circuit-to-logical-expression-design-doc",children:[(0,o.jsx)(n.em,{children:"Circuit to Logical Expression"})," Design Doc"]}),"\n",(0,o.jsxs)(n.h4,{id:"trevor-crystal-leon-montealegre-last-updated-june-19-2022",children:[(0,o.jsx)(n.em,{children:(0,o.jsx)(n.a,{href:"https://github.com/TGCrystal",children:"Trevor Crystal"})}),", ",(0,o.jsx)(n.em,{children:(0,o.jsx)(n.a,{href:"https://github.com/LeonMontealegre",children:"Leon Montealegre"})})," (Last updated ",(0,o.jsx)(n.em,{children:"June 19, 2022"}),")"]}),"\n",(0,o.jsxs)(i,{children:[(0,o.jsx)("summary",{children:(0,o.jsx)(n.p,{children:"Table of Contents"})}),(0,o.jsx)(l.A,{toc:h})]}),"\n",(0,o.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(n.p,{children:"Recently, a feature to generate a circuit from a logical boolean expression was added. This is an interesting feature and can be useful for those learning how the logic of digital circuitry works. There is, however, no way to do the reverse of this operation."}),"\n",(0,o.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,o.jsx)(n.p,{children:"Being able to see the expression that represents a selected circuit would be a useful and educational feature to have."}),"\n",(0,o.jsx)(n.h2,{id:"goals--non-goals",children:"Goals & Non-Goals"}),"\n",(0,o.jsx)(n.h3,{id:"goals",children:"Goals:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Allows users to see the expression of a circuit with AND, OR, XOR, or NOT gates (or their inverted variations)"}),"\n",(0,o.jsx)(n.li,{children:"Allows users to see the expression of a circuit described above that is inside of an IC"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"non-goals",children:"Non-Goals:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"We do not plan on implementing this feature with components like multiplexers, latches, entire ICs, etc."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"milestones",children:"Milestones"}),"\n",(0,o.jsx)(r.A,{start:"",milestones:[{date:"",explanation:"Add the additional required functionality in the current tree structure and merge"},{date:"",explanation:"Create and test functions for all intermediary steps"},{date:"",explanation:"Create and test combined action (or function) and ui"}],end:""}),"\n",(0,o.jsx)(n.h2,{id:"existing-solution",children:"Existing Solution"}),"\n",(0,o.jsx)(n.p,{children:"The user must manually figure out the expression that a circuit represents."}),"\n",(0,o.jsx)(n.h2,{id:"proposed-solution",children:"Proposed Solution"}),"\n",(0,o.jsx)(n.p,{children:"Proposed User Walk-Through:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"The users selects a valid circuit (including inputs and output)"}),"\n",(0,o.jsx)(n.li,{children:"The selection popup somehow indicates or allows an indication for the expression"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"alternative-solutions",children:"Alternative Solutions"}),"\n",(0,o.jsx)(n.p,{children:"None to consider"}),"\n",(0,o.jsx)(n.h2,{id:"testability",children:"Testability"}),"\n",(0,o.jsx)(n.p,{children:"The steps of circuit->tree, tree->tokens, and tokens->expression can all be tested independently. The entire process can be wrapped in a testable action."}),"\n",(0,o.jsx)(n.h2,{id:"impact",children:"Impact"}),"\n",(0,o.jsx)(n.p,{children:"The expression to circuit data structures should be modified to better represent a wider variety of circuits. Namely, the two main changes would be allowing variable number of input gates and representing negated gates."}),"\n",(0,o.jsx)(n.p,{children:"Representing a variable number of input gates for OR, NAND, and XNOR operations (and their negated versions) would allow for improved parsing in both directions."}),"\n",(0,o.jsxs)(n.p,{children:["Simplifying ",(0,o.jsx)(n.code,{children:"NOT+AND->NAND"})," alredy happens as an action one the entire circuit is generated. To best represent circuits when going from circuit to expression, it would be easier to just represent this at the abstract level."]}),"\n",(0,o.jsx)(n.p,{children:"There is one more case that we would not easily be able to represent at the abstract level. Whenever one component (other than an input) outputs to multiple different components, there is currently no simple representation we can modify. This wouldn't be a problem for circuit to expression, but it would mean that circuit to expression and expression to circuit are not perfect opposite actions of eachother."}),"\n",(0,o.jsx)(n.h2,{id:"known-unknowns",children:"Known Unknowns"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.del,{children:"The exact way the expression is represented in the Selection Popup is unknown. It could have a button that would directly display it, or, if the algorithm is efficient enough, can display the expression inline. That would mean there (probably) couldn't be any choices for how to format the output."})," The output will be shown in a popup along with settings, similar to the Expression to Circuit Popup."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.del,{children:"Should there be options to format the output (different operations, parenthesis usage, etc.)?"})," Yes"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.del,{children:"Should all operations be parenthesized (easy and literal) or should the parenthesis be removed if not necessary (hard and simplified)?"})," Option for it, simplify by default."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.del,{children:"The output can be confusing with unnamed inputs. Is there any way to remedy this?"}),' Ex: 2 Switches both named Switch, in the output they will be named "Switch1" and "Switch2". In the popup, after Generate is clicked, it can show labels (in the popup view only) for the names for the components.']}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"detailed-scoping",children:"Detailed Scoping"}),"\n",(0,o.jsx)(n.h3,{id:"milestone-1",children:"Milestone 1"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"InputTreeUnOpNode"})," and ",(0,o.jsx)(n.code,{children:"InputTreeBinOpNode"})," interfaces can both include a ",(0,o.jsx)(n.code,{children:"negated: boolean"})," property."]}),"\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"lChild"})," and ",(0,o.jsx)(n.code,{children:"rChild"})," properties of ",(0,o.jsx)(n.code,{children:"InputTreeBinOpNode"})," can be replaced by a tuple like ",(0,o.jsx)(n.code,{children:"children: [InputTree, InputTree, InputTree?, InputTree?, InputTree?, InputTree?, InputTree?, InputTree?]"})," (not sure if there is a cleaner way to do this, children must contain two through eight elements, inclusive)"]}),"\n",(0,o.jsxs)(n.li,{children:["Implement the above, test, and get merged into ",(0,o.jsx)(n.code,{children:"master"})]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"milestone-2",children:"Milestone 2"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Circuit to tree"}),"\n",(0,o.jsx)(n.li,{children:"Tree to tokens"}),"\n",(0,o.jsx)(n.li,{children:"Tokens to string (will need to know details of desired output formatting for this)"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"milestone-3",children:"Milestone 3"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Finalize the design of the ui"}),"\n",(0,o.jsx)(n.li,{children:"Create an action (or other function) to perform all of the parts created in Milestone 2, create tests for that"}),"\n",(0,o.jsx)(n.li,{children:"There will be a button in the Selection Popup to open a popup similar to the one for generating a circuit from an expression."}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The button in the Selection Popup will look something like this: ",(0,o.jsx)(n.img,{alt:"The Selection Popup with the added button",src:t(6991).A+"",width:"737",height:"445"})]}),"\n",(0,o.jsxs)(n.p,{children:["Before clicking Generate, the popup will look like this: ",(0,o.jsx)(n.img,{alt:"The popup before clicking Generate",src:t(4e3).A+"",width:"1134",height:"1190"})]}),"\n",(0,o.jsxs)(n.p,{children:["Afterwards, the expression will be shown below with an icon to quickly copy it: ",(0,o.jsx)(n.img,{alt:"The popup after clicking Generate",src:t(9565).A+"",width:"1134",height:"1190"})]}),"\n",(0,o.jsx)(n.p,{children:"Note that the preview in the top of the circuit will be similar to the one in Image Exporter with the user able to pan/zoom around and such."}),"\n",(0,o.jsx)(n.p,{children:'Also note the placement of labels after the "Generate" is clicked which will hopefully clarify issues with naming and duplicate names. Maybe a little popup warning saying that new names have been generated would be good too.'}),"\n",(0,o.jsx)(n.p,{children:"Also note that the generate button should probably gray out or dissapear after being clicked since generating more then once for the same circuit is pointless."})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},1782:(e,n,t)=>{t.d(n,{A:()=>l});t(8431);var i=t(2295);function o(e,n){n=n||8;const t=Math.pow(10,n+1)-1,i=Math.pow(10,n)/2-1;let o=0;for(var s=0;s<e.length;s++)o=(o+i*e.charCodeAt(s))%t;return o}const s=(()=>{const e=e=>{let n=e%2147483647;n<=0&&(n+=2147483646);return{randInt:(e,t)=>Math.floor((()=>{const e=16807*n%2147483647;return n=e,(e-1)/2147483646})()*(t-e+1))+e}};return n=>{const t=e(n??Math.floor(2147483647*Math.random()));return`hsl(${t.randInt(0,360)},${t.randInt(42,98)}%,${t.randInt(40,90)}%)`}})();function l(e){let{start:n,milestones:t,end:l}=e;const r=400/6,a=1*r/2,c=100/t.length-5;return(0,i.jsxs)("div",{style:{position:"relative",width:"100%",height:"400px"},children:[(0,i.jsx)("svg",{width:"100%",height:"100%",children:(0,i.jsxs)("g",{style:{transform:"translate(0, 50%)"},children:[(0,i.jsx)("rect",{y:`-${r/2}px`,width:"1px",height:`${r}px`,fill:"gray"}),(0,i.jsx)("text",{y:-r/2-5+"px",fill:"gray",alignmentBaseline:"baseline",children:n}),(0,i.jsx)("rect",{x:"calc(100% - 1px)",y:`-${r/2}px`,width:"1px",height:`${r}px`,fill:"gray"}),(0,i.jsx)("text",{x:"100%",y:-r/2-5+"px",fill:"gray",textAnchor:"end",alignmentBaseline:"baseline",children:l}),t.map((e,n)=>(n+1)/(t.length+1)*100).map((e,n)=>(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)("rect",{x:`${e}%`,y:`-${a/2}px`,width:"1px",height:`${a}px`,fill:"gray"}),(0,i.jsx)("text",{x:`${e}%`,y:(a/2+5)*(n%2==0?-1:1)+"px",fill:"gray",textAnchor:"middle",alignmentBaseline:n%2==0?"baseline":"hanging",children:t[n].date})]})),(0,i.jsx)("rect",{width:"100%",height:"1px",fill:"gray"})]})}),t.map((e,n)=>{const l=(n+1)/(t.length+1)*100,r=n%2==0?a+5:-(a+5)-150;return(0,i.jsx)("a",{href:`#milestone-${n+1}`,style:{color:"inherit"},children:(0,i.jsxs)("div",{style:{position:"absolute",display:"flex",flexDirection:"column",left:l-c/2+"%",top:`calc(50% + ${r}px)`,width:`${c}%`,height:"150px",borderRadius:"5px",backgroundColor:s(o(e.date+e.explanation))},children:[(0,i.jsxs)("div",{style:{width:"100%",marginTop:"5px",flex:"0 1 auto",textAlign:"center",fontWeight:"bold",overflow:"hidden",textOverflow:"clip",whiteSpace:"nowrap"},children:["Milestone ",n+1]}),(0,i.jsx)("div",{style:{width:"100%",marginTop:"5px",flex:"1 1 auto",textAlign:"center",overflow:"clip",textOverflow:"ellipsis",whiteSpace:"break-spaces"},children:e.explanation})]})})})]})}},4e3:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/MockupPart2-0a518216ea4b14b4e81ac25f843d73b1.jpg"},6663:(e,n,t)=>{t.d(n,{A:()=>l});t(8431);var i=t(8362);const o={tableOfContentsInline:"tableOfContentsInline_YMVU"};var s=t(2295);function l(e){let{toc:n,minHeadingLevel:t,maxHeadingLevel:l}=e;return(0,s.jsx)("div",{className:o.tableOfContentsInline,children:(0,s.jsx)(i.A,{toc:n,minHeadingLevel:t,maxHeadingLevel:l,className:"table-of-contents",linkClassName:null})})}},6991:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/MockupPart1-73d41a4cd73a81f8ffb14deb6a7977fb.jpg"},8002:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>r});var i=t(8431);const o={},s=i.createContext(o);function l(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),i.createElement(s.Provider,{value:n},e.children)}},8362:(e,n,t)=>{t.d(n,{A:()=>m});var i=t(8431),o=t(4795);function s(e){const n=e.map(e=>({...e,parentIndex:-1,children:[]})),t=Array(7).fill(-1);n.forEach((e,n)=>{const i=t.slice(2,e.level);e.parentIndex=Math.max(...i),t[e.level]=n});const i=[];return n.forEach(e=>{const{parentIndex:t,...o}=e;t>=0?n[t].children.push(o):i.push(o)}),i}function l(e){let{toc:n,minHeadingLevel:t,maxHeadingLevel:i}=e;return n.flatMap(e=>{const n=l({toc:e.children,minHeadingLevel:t,maxHeadingLevel:i});return function(e){return e.level>=t&&e.level<=i}(e)?[{...e,children:n}]:n})}function r(e){const n=e.getBoundingClientRect();return n.top===n.bottom?r(e.parentNode):n}function a(e,n){let{anchorTopOffset:t}=n;const i=e.find(e=>r(e).top>=t);if(i){return function(e){return e.top>0&&e.bottom<window.innerHeight/2}(r(i))?i:e[e.indexOf(i)-1]??null}return e[e.length-1]??null}function c(){const e=(0,i.useRef)(0),{navbar:{hideOnScroll:n}}=(0,o.p)();return(0,i.useEffect)(()=>{e.current=n?0:document.querySelector(".navbar").clientHeight},[n]),e}function d(e){const n=(0,i.useRef)(void 0),t=c();(0,i.useEffect)(()=>{if(!e)return()=>{};const{linkClassName:i,linkActiveClassName:o,minHeadingLevel:s,maxHeadingLevel:l}=e;function r(){const e=function(e){return Array.from(document.getElementsByClassName(e))}(i),r=function(e){let{minHeadingLevel:n,maxHeadingLevel:t}=e;const i=[];for(let o=n;o<=t;o+=1)i.push(`h${o}.anchor`);return Array.from(document.querySelectorAll(i.join()))}({minHeadingLevel:s,maxHeadingLevel:l}),c=a(r,{anchorTopOffset:t.current}),d=e.find(e=>c&&c.id===function(e){return decodeURIComponent(e.href.substring(e.href.indexOf("#")+1))}(e));e.forEach(e=>{!function(e,t){t?(n.current&&n.current!==e&&n.current.classList.remove(o),e.classList.add(o),n.current=e):e.classList.remove(o)}(e,e===d)})}return document.addEventListener("scroll",r),document.addEventListener("resize",r),r(),()=>{document.removeEventListener("scroll",r),document.removeEventListener("resize",r)}},[e,t])}var h=t(7809),u=t(2295);function p(e){let{toc:n,className:t,linkClassName:i,isChild:o}=e;return n.length?(0,u.jsx)("ul",{className:o?void 0:t,children:n.map(e=>(0,u.jsxs)("li",{children:[(0,u.jsx)(h.A,{to:`#${e.id}`,className:i??void 0,dangerouslySetInnerHTML:{__html:e.value}}),(0,u.jsx)(p,{isChild:!0,toc:e.children,className:t,linkClassName:i})]},e.id))}):null}const x=i.memo(p);function m(e){let{toc:n,className:t="table-of-contents table-of-contents__left-border",linkClassName:r="table-of-contents__link",linkActiveClassName:a,minHeadingLevel:c,maxHeadingLevel:h,...p}=e;const m=(0,o.p)(),g=c??m.tableOfContents.minHeadingLevel,f=h??m.tableOfContents.maxHeadingLevel,v=function(e){let{toc:n,minHeadingLevel:t,maxHeadingLevel:o}=e;return(0,i.useMemo)(()=>l({toc:s(n),minHeadingLevel:t,maxHeadingLevel:o}),[n,t,o])}({toc:n,minHeadingLevel:g,maxHeadingLevel:f});return d((0,i.useMemo)(()=>{if(r&&a)return{linkClassName:r,linkActiveClassName:a,minHeadingLevel:g,maxHeadingLevel:f}},[r,a,g,f])),(0,u.jsx)(x,{toc:v,className:t,linkClassName:r,...p})}},9565:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/MockupPart3-4e72cf631cce3b2df99c420d6d8a92fe.jpg"}}]);