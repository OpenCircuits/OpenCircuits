"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[42],{4640:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"Introduction/Guides/GoCrashCourse","title":"Go Crash Course","description":"Writing Go Code","source":"@site/../../../../docs/Introduction/Guides/GoCrashCourse.md","sourceDirName":"Introduction/Guides","slug":"/Introduction/Guides/GoCrashCourse","permalink":"/Introduction/Guides/GoCrashCourse","draft":false,"unlisted":false,"editUrl":"https://github.com/OpenCircuits/OpenCircuits/edit/master/docs/Introduction/Guides/GoCrashCourse.md","tags":[],"version":"current","frontMatter":{"title":"Go Crash Course"},"sidebar":"introSidebar","previous":{"title":"Common issues with pull requests","permalink":"/Introduction/Guides/Common issues with pull requests"},"next":{"title":"Order of imports","permalink":"/Introduction/Guides/Imports"}}');var r=n(2295),o=n(8002);const a={title:"Go Crash Course"},s="Crash Course for Developing our Go Code",c={},d=[{value:"Writing Go Code",id:"writing-go-code",level:2},{value:"Go syntax... briefly",id:"go-syntax-briefly",level:3},{value:"Writing self-contained / modular / decoupled Go code",id:"writing-self-contained--modular--decoupled-go-code",level:3},{value:"Functional Dependency Injection (AKA how we organize routes)",id:"functional-dependency-injection-aka-how-we-organize-routes",level:3},{value:"Contributing to the Go Code",id:"contributing-to-the-go-code",level:2},{value:"AuthenticationManager",id:"authenticationmanager",level:3},{value:"CircuitStorageInterfaceFactory",id:"circuitstorageinterfacefactory",level:3},{value:"The &quot;Circuit&quot; Model",id:"the-circuit-model",level:3}];function h(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"crash-course-for-developing-our-go-code",children:"Crash Course for Developing our Go Code"})}),"\n",(0,r.jsx)(t.h2,{id:"writing-go-code",children:"Writing Go Code"}),"\n",(0,r.jsx)(t.p,{children:"This is kind of a WIP.  If you are reading this and have suggestions, we will be receptive.  If you are just starting with Go / OpenCircuits, please give us your feedback so we can make our getting-started material more helpful."}),"\n",(0,r.jsx)(t.h3,{id:"go-syntax-briefly",children:"Go syntax... briefly"}),"\n",(0,r.jsx)(t.p,{children:"The Go language is kind of like C mixed with python.  It is syntactically simple and does not support high level language features like list comprehensions, but it has more quality-of-life features than C does (i.e. garbage collection, lambdas).  This simplicity is the primary reason we chose Go over Rust and the strong typing is why we chose Go over Python or JavaScript.  TypeScript is still being considered as an alternative."}),"\n",(0,r.jsxs)(t.p,{children:["There is a canonical Go style, which can be enforced by running ",(0,r.jsx)(t.code,{children:"go fmt ."}),".  This command can also do other things.  Please run this before committing; eventually we will make this a git hook.  Yes, I know Go uses tabs for indentation.  Yes, we're following these guidelines."]}),"\n",(0,r.jsx)(t.p,{children:"Here's the anatomy of some simple Go code:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'// Functions can return multiple values, but they are NOT tuples.  They must be unpacked by the caller.\r\n// It is idiomatic for functions that fail to return an "error" type that is nil on success\r\nfunc foo(param int, param1 *float64) (int, error) {\r\n    // Variables can be declared explicitly\r\n    var tmp int\r\n    tmp = param\r\n\r\n    // Or declaired inline and type "int" is inferred\r\n    tmp1 := param\r\n\r\n    // There are pointers, like in C, and they can be nil\r\n    if param1 != nil {\r\n        // Casts are function-style casts\r\n        *param1 = float64(param)\r\n    } else {\r\n        // There are no exceptions, only errors, which can be\r\n        //  cumbersome, but won\'t surprise you like exceptions\r\n        return 0, errors.New("param1 was nil")\r\n    }\r\n\r\n    return tmp1+1, nil\r\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:['You will find that go\'s error checking can get tedious and redundant and anyone who has used Haskell will be asking "where is <$>?"  The philosophy is that explicit error checking is easier to read and simpler to reason about than things like fmap or null propagation.  You will be writing ',(0,r.jsx)(t.code,{children:"if err == nil { ..."})," a lot, but that's a good thing, because we want to be mindful of error cases."]}),"\n",(0,r.jsx)(t.h3,{id:"writing-self-contained--modular--decoupled-go-code",children:"Writing self-contained / modular / decoupled Go code"}),"\n",(0,r.jsx)(t.p,{children:'Go has a variety of features to help us write better code.  This is not exhaustive and I am not an expert on Go, so use this as a starting point.  This is also a crash-course in "Principles of Software".'}),"\n",(0,r.jsxs)(t.p,{children:["Go does not have the object-oriented features that C++ and Java has.  There are structs, but these are more like C structs and privacy is managed per-package.  Things declared in a package that start with an upper-case letter are exported from that package: ",(0,r.jsx)(t.code,{children:"func Foo() {}"}),", ",(0,r.jsx)(t.code,{children:"type Data struct {}"}),".  Things declared with a lower-case letter are not exported from the package, but available to sub-packages: ",(0,r.jsx)(t.code,{children:"func privFoo() {}"}),", ",(0,r.jsx)(t.code,{children:"type privData struct {}"}),".  If we combine this knowledge with another Go feature, interfaces, we can have private code / data types in packages that expose features defined outside the package.  Packages should obey the directory structure,"]}),"\n",(0,r.jsx)(t.p,{children:"We'll use a simplified version of our authentication interface as an example:"}),"\n",(0,r.jsx)(t.p,{children:"Let's define our authentication interface as:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"type AuthenticationMethod interface {\r\n\tRegisterHandlers(*gin.Engine)\r\n\tExtractIdentity(string) (string, error)\r\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"In a sub-package, we can define a trivial authentication method that requires no password (NoAuth, used for development)."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:"// This is out private data type; it has no data since it doesn't do anything,\r\n//  but it serves as a type to satisfy the 'AuthenticationMethod' interface\r\ntype noLoginAuthenticationProvider struct {\r\n}\r\n\r\n// At this point, the Go compiler checks that '*noLoginAuthenticationProvider' satisfies the\r\n//  'AuthenticationMethod' interface implicitly.  This is an idiomatic constructor for an object\r\nfunc NewNoAuth() AuthenticationMethod {\r\n    // We can create a pointer to an object with '&' and the Go garbage collector will\r\n    //  make sure it will only get released when its no longer being used\r\n    return &noLoginAuthenticationProvider{}\r\n}\r\n\r\n// This is the syntax for defining member functions on a struct.  You can only define member functions\r\n//  in the package that defines the type.\r\nfunc (nl noLoginAuthenticationProvider) RegisterHandlers(engine *gin.Engine) {\r\n}\r\n\r\n// You can also define member functions on a pointer to the struct.  This allows you to modify the\r\n//  data in the struct in the function.  Without the pointer, the struct would be copied before calling.\r\nfunc (nl *noLoginAuthenticationProvider) RegisterHandlers(engine *gin.Engine) {\r\n}\r\n\r\nfunc (nl noLoginAuthenticationProvider) ExtractIdentity(token string) (string, error) {\r\n    if token == \"\" {\r\n        return \"\", errors.New(\"user id cannot be blank in no_auth\")\r\n    }\r\n    return \"no_auth_\" + token, nil\r\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Notice that there is nothing that explicitly says that ",(0,r.jsx)(t.code,{children:"*noLoginAuthenticationProvider"})," implements the ",(0,r.jsx)(t.code,{children:"AuthenticationMethod"})," interface.  This is because interfaces are checked implicitly and there would be a compiler error if ",(0,r.jsx)(t.code,{children:"*noLoginAuthenticationProvider"})," didn't satisfy the interface.  Since none of the interface functions need to modify our internal data structure, we could also say that ",(0,r.jsx)(t.code,{children:"noLoginAuthenticationProvider"})," (without the pointer) satisfies the interface.  If struct ",(0,r.jsx)(t.code,{children:"X"})," satisfies the interface ",(0,r.jsx)(t.code,{children:"A"}),", then struct ",(0,r.jsx)(t.code,{children:"*X"})," also satisfies ",(0,r.jsx)(t.code,{children:"A"}),", but not vice versa."]}),"\n",(0,r.jsx)(t.h3,{id:"functional-dependency-injection-aka-how-we-organize-routes",children:"Functional Dependency Injection (AKA how we organize routes)"}),"\n",(0,r.jsx)(t.p,{children:"This might sound complicated, but its pretty simple in practice.  It means instead of creating a bunch of objects and interfaces for single-function abstractions, we use go's lambdas to help us write smaller code."}),"\n",(0,r.jsx)(t.p,{children:"Here's an example from the API router.  We use it to inject authentication into routes:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'// This is a function that converts normal routes into authenticated routes.  The \'_\' is a name placeholder for when the name is not needed\r\nfunc authenticatedHandler(manager auth.AuthenticationManager, handler func(_ *gin.Context, _ model.UserId)) func(c *gin.Context) {\r\n        // We can return anonymous functions (lambdas) that can bind/refer to named variables in the enclosing scope\r\n\treturn func(c *gin.Context) {\r\n                // Use the injected/bound "manager" object to find out the authentication method\r\n\t\tam := manager.MatchToken(c.GetHeader("authType"))\r\n\t\tif am == nil {\r\n                        // Go has anonymous structs, but the type inference isn\'t that great\r\n\t\t\tc.JSON(http.StatusBadRequest, struct {\r\n\t\t\t\tmessage string\r\n\t\t\t}{\r\n\t\t\t\tmessage: "Cannot call authenticated route without valid authentication header",\r\n\t\t\t})\r\n\t\t\treturn\r\n\t\t}\r\n                // Use the authentication methdo to extract an identity from the reported user\'s Id\r\n\t\tid, err := (*am).ExtractIdentity(c.GetHeader("authId"))\r\n\t\tif err != nil {\r\n\t\t\tc.JSON(http.StatusBadRequest, nil)\r\n\t\t\treturn\r\n\t\t}\r\n                // After we retrieved the identity \'id\', call the function to handle the request with the user\'s identity\r\n\t\thandler(c, id)\r\n\t}\r\n}\r\n\r\n// A trivial handler for testing authenticated routes\r\nfunc pingHandler(c *gin.Context, userId model.UserId) {\r\n\tc.JSON(http.StatusOK, fmt.Sprintf("Thank you for pinging: %s", userId))\r\n}\r\n\r\n// Registers the route in \'gin\'\r\nfunc RegisterRoutes(router *gin.Engine, manager auth.AuthenticationManager) {\r\n    // This is \'Function Dependency Injection\'.\r\n\trouter.GET("/api/ping", authenticatedHandler(manager, pingHandler))\r\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:'Now i\'ll explain the name.  "Functional" means we use functions as first-class objects when executing the desired behavior.  "Dependency Injection" means there is some object that our handler needs (AuthenticationManager), but we construct the object separately and "inject" it in when needed.  While this object isn\'t an interface, this pattern is also used if the exact type of the object is not known at runtime.  Put together, it means we wrap each layer of behavior into a separate function that calls into the next layer with the results of the current layer and previous layers.'}),"\n",(0,r.jsx)(t.p,{children:"If you don't need to be writing your own wrapper functions, you don't have to fully understand this.  You just need to know which wrappers you need and existing routes can be helpful as a template."}),"\n",(0,r.jsx)(t.h2,{id:"contributing-to-the-go-code",children:"Contributing to the Go Code"}),"\n",(0,r.jsx)(t.p,{children:"You just read a crash course in developing Go code, using some of our code as examples.  It is important that this code is stable and secure since its handling user's private data.  While we do not handle passwords or personal information, the user's circuits are still private.  In general, do not expose more behavior than you need to from a package and don't assume any client-provided data is correct or valid."}),"\n",(0,r.jsx)(t.p,{children:"You saw above how to add new routes to the API.  Adding new routes to the website is similiar."}),"\n",(0,r.jsx)(t.p,{children:"If you've never dealt with pointers before, Go's pointers have training wheels.  Just remember to check that pointer types are non-null unless you can trivially prove that they will never be null.  If you accidentally use a null pointer, it will probably crash the server (which is bad)."}),"\n",(0,r.jsx)(t.p,{children:"The code is fairly simple, much simpler than the front-end code, but its designed to be modular and expandable so some design choices are not immediately obvious."}),"\n",(0,r.jsx)(t.p,{children:"Now lets dive into the specific parts of the Go code, how they're organized, and why."}),"\n",(0,r.jsx)(t.h3,{id:"authenticationmanager",children:"AuthenticationManager"}),"\n",(0,r.jsxs)(t.p,{children:["This object allows us to support multiple ",(0,r.jsx)(t.code,{children:"AuthenticationMethod"}),"s (i.e. Google, Facebook, GitHub) at the same time.  The ",(0,r.jsx)(t.code,{children:"authenticationHandler"})," (above) resolves the user's id in-flight so it can be used generically in the routes.  Once a user has passed through this layer, we can assume that the ",(0,r.jsx)(t.code,{children:"userId"})," is valid."]}),"\n",(0,r.jsx)(t.h3,{id:"circuitstorageinterfacefactory",children:"CircuitStorageInterfaceFactory"}),"\n",(0,r.jsx)(t.p,{children:"This is a usage of the \"Abstract Factory\" pattern.  In general, this pattern allows us to use dependency injection (explained above) to vary the behavior of code at runtime, but is thread-safe since each object created by the factory can be distinct.  This is an important requirement of a web-server that is multi-threaded.  In this specific case, the factory allows us to use different backing stores for the circuit data without exposing how we interface with these backing stores to the code that processes the 'save' request."}),"\n",(0,r.jsx)(t.p,{children:"You probably will not need to create a new one of these since the ones we support (in-memory, sqlite, and GCP) are sufficient, but its important to understand why its organized this way."}),"\n",(0,r.jsx)(t.h3,{id:"the-circuit-model",children:'The "Circuit" Model'}),"\n",(0,r.jsx)(t.p,{children:"There are two parts of the circuit on the backend.  There's some metadata, which is the data the backend needs access to, and there's the \"Designer\", which is the circuit's functional contents (gates, wires, etc.).  We avoid needing to decode the functional components in the Go code by factoring the metadata out into a separate structure.  All data that is needed by the backend code and is not tightly coupled to the structure of the circuit should be in the metadata."})]})}function u(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8002:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>s});var i=n(8431);const r={},o=i.createContext(r);function a(e){const t=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);