import {Result}         from "shared/api/circuit/utils/Result";
import {OperatorFormat} from "./Constants/DataStructures";
import {FORMATS}        from "./Constants/Formats";

import {GenerateInputTree} from "./GenerateInputTree";
import {GenerateTokens}    from "./GenerateTokens";
import {TreeToCircuit}     from "./TreeToCircuit";
import {DigitalCircuit}    from "digital/api/circuit/public";


/**
 * Main driver function for parsing an expression into a circuit.
 *
 * @param inputs     A map correlating input name to the type of component it will represent.
 * @param expression The expression to be parsed.
 * @param output     The name of the component to use as an output.
 * @param ops        The strings used to represent the different operators.
 * @returns          The circuit generated by the given expression.
 *                   In the case of error, then an error will be returned indicating one of the following:
 *                   - Parenthesis do not include anything (such as "()").
 *                   - An opening parenthesis is missing a corresponding closing parenthesis (such as "(").
 *                   - A closing parenthesis is missing a corresponding opening parenthesis (such as ")").
 *                   - `|`, `&`, or `^` are missing an operand on their left (such as "a|").
 *                   - `|`, `&`, `^`, or `!` are missing an operand on their right (such as "!a").
 *                   - There is no operator between two inputs (such as "a b").
 *                   - The expression references an input not found in inputs.
 *                   - If ops is missing the keys "|", "^", "&", "(", ")", or "separator".
 *                   - If the value in ops for keys "|", "^", "&", "(", ")", or "separator" is "".
 */
export function ExpressionToCircuit(inputs: ReadonlyMap<string, string>,
                                    expression: string,
                                    output: string,
                                    ops: OperatorFormat = FORMATS[0]): Result<DigitalCircuit> {
    return GenerateTokens(expression, ops).andThen((tokenList) =>
        GenerateInputTree(tokenList, ops.ops).map((connectedTree) =>
            TreeToCircuit(connectedTree, inputs, output)
        )
    );
}
