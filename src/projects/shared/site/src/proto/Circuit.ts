// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.30.2
// source: src/projects/shared/site/src/proto/Circuit.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "";

export interface Prop {
  intVal?: number | undefined;
  floatVal?: number | undefined;
  strVal?: string | undefined;
  boolVal?: boolean | undefined;
}

/** TODO: kind? */
export interface Port {
  group: string;
  index: number;
  name?: string | undefined;
  otherProps: { [key: string]: Prop };
}

export interface Port_OtherPropsEntry {
  key: string;
  value: Prop | undefined;
}

export interface Component {
  kind: number;
  /** Index of the IC in circuit.ics */
  icIdx?: number | undefined;
  portConfigIdx?: number | undefined;
  name?: string | undefined;
  x?: number | undefined;
  y?: number | undefined;
  angle?: number | undefined;
  otherProps: { [key: string]: Prop };
  portOverrides: Port[];
}

export interface Component_OtherPropsEntry {
  key: string;
  value: Prop | undefined;
}

export interface Wire {
  kind?:
    | number
    | undefined;
  /** The index of the 1st port's parent component in circuit.components */
  p1ParentIdx: number;
  p1Group: number;
  p1Idx: number;
  /** The index of the 2nd port's parent component in circuit.components */
  p2ParentIdx: number;
  p2Group: number;
  p2Idx: number;
  name?: string | undefined;
  color?: number | undefined;
  otherProps: { [key: string]: Prop };
}

export interface Wire_OtherPropsEntry {
  key: string;
  value: Prop | undefined;
}

export interface Camera {
  x: number;
  y: number;
  zoom: number;
}

export interface CircuitMetadata {
  id: string;
  name: string;
  desc: string;
  version: string;
}

export interface IntegratedCircuitMetadata {
  metadata: CircuitMetadata | undefined;
  displayWidth: number;
  displayHeight: number;
  portGroups: { [key: string]: number };
  pins: IntegratedCircuitMetadata_Pin[];
}

export interface IntegratedCircuitMetadata_PortGroupsEntry {
  key: string;
  value: number;
}

export interface IntegratedCircuitMetadata_Pin {
  internalCompIdx: number;
  internalPortIdx: number;
  group: number;
  name: string;
  x: number;
  y: number;
  dx: number;
  dy: number;
}

export interface IntegratedCircuit {
  metadata: IntegratedCircuitMetadata | undefined;
  components: Component[];
  wires: Wire[];
}

export interface Circuit {
  metadata: CircuitMetadata | undefined;
  camera: Camera | undefined;
  ics: IntegratedCircuit[];
  /** Order of components will dictate the z-ordering for them. */
  components: Component[];
  wires: Wire[];
}

function createBaseProp(): Prop {
  return { intVal: undefined, floatVal: undefined, strVal: undefined, boolVal: undefined };
}

export const Prop: MessageFns<Prop> = {
  encode(message: Prop, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.intVal !== undefined) {
      writer.uint32(8).int32(message.intVal);
    }
    if (message.floatVal !== undefined) {
      writer.uint32(21).float(message.floatVal);
    }
    if (message.strVal !== undefined) {
      writer.uint32(26).string(message.strVal);
    }
    if (message.boolVal !== undefined) {
      writer.uint32(32).bool(message.boolVal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Prop {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.intVal = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.floatVal = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.strVal = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.boolVal = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Prop {
    return {
      intVal: isSet(object.intVal) ? globalThis.Number(object.intVal) : undefined,
      floatVal: isSet(object.floatVal) ? globalThis.Number(object.floatVal) : undefined,
      strVal: isSet(object.strVal) ? globalThis.String(object.strVal) : undefined,
      boolVal: isSet(object.boolVal) ? globalThis.Boolean(object.boolVal) : undefined,
    };
  },

  toJSON(message: Prop): unknown {
    const obj: any = {};
    if (message.intVal !== undefined) {
      obj.intVal = Math.round(message.intVal);
    }
    if (message.floatVal !== undefined) {
      obj.floatVal = message.floatVal;
    }
    if (message.strVal !== undefined) {
      obj.strVal = message.strVal;
    }
    if (message.boolVal !== undefined) {
      obj.boolVal = message.boolVal;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Prop>, I>>(base?: I): Prop {
    return Prop.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Prop>, I>>(object: I): Prop {
    const message = createBaseProp();
    message.intVal = object.intVal ?? undefined;
    message.floatVal = object.floatVal ?? undefined;
    message.strVal = object.strVal ?? undefined;
    message.boolVal = object.boolVal ?? undefined;
    return message;
  },
};

function createBasePort(): Port {
  return { group: "", index: 0, name: undefined, otherProps: {} };
}

export const Port: MessageFns<Port> = {
  encode(message: Port, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== "") {
      writer.uint32(10).string(message.group);
    }
    if (message.index !== 0) {
      writer.uint32(16).int32(message.index);
    }
    if (message.name !== undefined) {
      writer.uint32(26).string(message.name);
    }
    Object.entries(message.otherProps).forEach(([key, value]) => {
      Port_OtherPropsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Port {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePort();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.group = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.index = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Port_OtherPropsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.otherProps[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Port {
    return {
      group: isSet(object.group) ? globalThis.String(object.group) : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      otherProps: isObject(object.otherProps)
        ? Object.entries(object.otherProps).reduce<{ [key: string]: Prop }>((acc, [key, value]) => {
          acc[key] = Prop.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Port): unknown {
    const obj: any = {};
    if (message.group !== "") {
      obj.group = message.group;
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.otherProps) {
      const entries = Object.entries(message.otherProps);
      if (entries.length > 0) {
        obj.otherProps = {};
        entries.forEach(([k, v]) => {
          obj.otherProps[k] = Prop.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Port>, I>>(base?: I): Port {
    return Port.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Port>, I>>(object: I): Port {
    const message = createBasePort();
    message.group = object.group ?? "";
    message.index = object.index ?? 0;
    message.name = object.name ?? undefined;
    message.otherProps = Object.entries(object.otherProps ?? {}).reduce<{ [key: string]: Prop }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Prop.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBasePort_OtherPropsEntry(): Port_OtherPropsEntry {
  return { key: "", value: undefined };
}

export const Port_OtherPropsEntry: MessageFns<Port_OtherPropsEntry> = {
  encode(message: Port_OtherPropsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Prop.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Port_OtherPropsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePort_OtherPropsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Prop.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Port_OtherPropsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Prop.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Port_OtherPropsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Prop.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Port_OtherPropsEntry>, I>>(base?: I): Port_OtherPropsEntry {
    return Port_OtherPropsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Port_OtherPropsEntry>, I>>(object: I): Port_OtherPropsEntry {
    const message = createBasePort_OtherPropsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Prop.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseComponent(): Component {
  return {
    kind: 0,
    icIdx: undefined,
    portConfigIdx: undefined,
    name: undefined,
    x: undefined,
    y: undefined,
    angle: undefined,
    otherProps: {},
    portOverrides: [],
  };
}

export const Component: MessageFns<Component> = {
  encode(message: Component, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== 0) {
      writer.uint32(8).uint32(message.kind);
    }
    if (message.icIdx !== undefined) {
      writer.uint32(16).uint32(message.icIdx);
    }
    if (message.portConfigIdx !== undefined) {
      writer.uint32(24).uint32(message.portConfigIdx);
    }
    if (message.name !== undefined) {
      writer.uint32(34).string(message.name);
    }
    if (message.x !== undefined) {
      writer.uint32(45).float(message.x);
    }
    if (message.y !== undefined) {
      writer.uint32(53).float(message.y);
    }
    if (message.angle !== undefined) {
      writer.uint32(61).float(message.angle);
    }
    Object.entries(message.otherProps).forEach(([key, value]) => {
      Component_OtherPropsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    for (const v of message.portOverrides) {
      Port.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Component {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComponent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.kind = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.icIdx = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.portConfigIdx = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.y = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.angle = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = Component_OtherPropsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.otherProps[entry8.key] = entry8.value;
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.portOverrides.push(Port.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Component {
    return {
      kind: isSet(object.kind) ? globalThis.Number(object.kind) : 0,
      icIdx: isSet(object.icIdx) ? globalThis.Number(object.icIdx) : undefined,
      portConfigIdx: isSet(object.portConfigIdx) ? globalThis.Number(object.portConfigIdx) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      x: isSet(object.x) ? globalThis.Number(object.x) : undefined,
      y: isSet(object.y) ? globalThis.Number(object.y) : undefined,
      angle: isSet(object.angle) ? globalThis.Number(object.angle) : undefined,
      otherProps: isObject(object.otherProps)
        ? Object.entries(object.otherProps).reduce<{ [key: string]: Prop }>((acc, [key, value]) => {
          acc[key] = Prop.fromJSON(value);
          return acc;
        }, {})
        : {},
      portOverrides: globalThis.Array.isArray(object?.portOverrides)
        ? object.portOverrides.map((e: any) => Port.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Component): unknown {
    const obj: any = {};
    if (message.kind !== 0) {
      obj.kind = Math.round(message.kind);
    }
    if (message.icIdx !== undefined) {
      obj.icIdx = Math.round(message.icIdx);
    }
    if (message.portConfigIdx !== undefined) {
      obj.portConfigIdx = Math.round(message.portConfigIdx);
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.x !== undefined) {
      obj.x = message.x;
    }
    if (message.y !== undefined) {
      obj.y = message.y;
    }
    if (message.angle !== undefined) {
      obj.angle = message.angle;
    }
    if (message.otherProps) {
      const entries = Object.entries(message.otherProps);
      if (entries.length > 0) {
        obj.otherProps = {};
        entries.forEach(([k, v]) => {
          obj.otherProps[k] = Prop.toJSON(v);
        });
      }
    }
    if (message.portOverrides?.length) {
      obj.portOverrides = message.portOverrides.map((e) => Port.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Component>, I>>(base?: I): Component {
    return Component.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Component>, I>>(object: I): Component {
    const message = createBaseComponent();
    message.kind = object.kind ?? 0;
    message.icIdx = object.icIdx ?? undefined;
    message.portConfigIdx = object.portConfigIdx ?? undefined;
    message.name = object.name ?? undefined;
    message.x = object.x ?? undefined;
    message.y = object.y ?? undefined;
    message.angle = object.angle ?? undefined;
    message.otherProps = Object.entries(object.otherProps ?? {}).reduce<{ [key: string]: Prop }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Prop.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.portOverrides = object.portOverrides?.map((e) => Port.fromPartial(e)) || [];
    return message;
  },
};

function createBaseComponent_OtherPropsEntry(): Component_OtherPropsEntry {
  return { key: "", value: undefined };
}

export const Component_OtherPropsEntry: MessageFns<Component_OtherPropsEntry> = {
  encode(message: Component_OtherPropsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Prop.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Component_OtherPropsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComponent_OtherPropsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Prop.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Component_OtherPropsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Prop.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Component_OtherPropsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Prop.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Component_OtherPropsEntry>, I>>(base?: I): Component_OtherPropsEntry {
    return Component_OtherPropsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Component_OtherPropsEntry>, I>>(object: I): Component_OtherPropsEntry {
    const message = createBaseComponent_OtherPropsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Prop.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseWire(): Wire {
  return {
    kind: undefined,
    p1ParentIdx: 0,
    p1Group: 0,
    p1Idx: 0,
    p2ParentIdx: 0,
    p2Group: 0,
    p2Idx: 0,
    name: undefined,
    color: undefined,
    otherProps: {},
  };
}

export const Wire: MessageFns<Wire> = {
  encode(message: Wire, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== undefined) {
      writer.uint32(8).uint32(message.kind);
    }
    if (message.p1ParentIdx !== 0) {
      writer.uint32(16).uint32(message.p1ParentIdx);
    }
    if (message.p1Group !== 0) {
      writer.uint32(24).uint32(message.p1Group);
    }
    if (message.p1Idx !== 0) {
      writer.uint32(32).uint32(message.p1Idx);
    }
    if (message.p2ParentIdx !== 0) {
      writer.uint32(40).uint32(message.p2ParentIdx);
    }
    if (message.p2Group !== 0) {
      writer.uint32(48).uint32(message.p2Group);
    }
    if (message.p2Idx !== 0) {
      writer.uint32(56).uint32(message.p2Idx);
    }
    if (message.name !== undefined) {
      writer.uint32(66).string(message.name);
    }
    if (message.color !== undefined) {
      writer.uint32(72).uint32(message.color);
    }
    Object.entries(message.otherProps).forEach(([key, value]) => {
      Wire_OtherPropsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Wire {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWire();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.kind = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.p1ParentIdx = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.p1Group = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.p1Idx = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.p2ParentIdx = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.p2Group = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.p2Idx = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.color = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = Wire_OtherPropsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.otherProps[entry10.key] = entry10.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Wire {
    return {
      kind: isSet(object.kind) ? globalThis.Number(object.kind) : undefined,
      p1ParentIdx: isSet(object.p1ParentIdx) ? globalThis.Number(object.p1ParentIdx) : 0,
      p1Group: isSet(object.p1Group) ? globalThis.Number(object.p1Group) : 0,
      p1Idx: isSet(object.p1Idx) ? globalThis.Number(object.p1Idx) : 0,
      p2ParentIdx: isSet(object.p2ParentIdx) ? globalThis.Number(object.p2ParentIdx) : 0,
      p2Group: isSet(object.p2Group) ? globalThis.Number(object.p2Group) : 0,
      p2Idx: isSet(object.p2Idx) ? globalThis.Number(object.p2Idx) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      color: isSet(object.color) ? globalThis.Number(object.color) : undefined,
      otherProps: isObject(object.otherProps)
        ? Object.entries(object.otherProps).reduce<{ [key: string]: Prop }>((acc, [key, value]) => {
          acc[key] = Prop.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Wire): unknown {
    const obj: any = {};
    if (message.kind !== undefined) {
      obj.kind = Math.round(message.kind);
    }
    if (message.p1ParentIdx !== 0) {
      obj.p1ParentIdx = Math.round(message.p1ParentIdx);
    }
    if (message.p1Group !== 0) {
      obj.p1Group = Math.round(message.p1Group);
    }
    if (message.p1Idx !== 0) {
      obj.p1Idx = Math.round(message.p1Idx);
    }
    if (message.p2ParentIdx !== 0) {
      obj.p2ParentIdx = Math.round(message.p2ParentIdx);
    }
    if (message.p2Group !== 0) {
      obj.p2Group = Math.round(message.p2Group);
    }
    if (message.p2Idx !== 0) {
      obj.p2Idx = Math.round(message.p2Idx);
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.color !== undefined) {
      obj.color = Math.round(message.color);
    }
    if (message.otherProps) {
      const entries = Object.entries(message.otherProps);
      if (entries.length > 0) {
        obj.otherProps = {};
        entries.forEach(([k, v]) => {
          obj.otherProps[k] = Prop.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Wire>, I>>(base?: I): Wire {
    return Wire.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Wire>, I>>(object: I): Wire {
    const message = createBaseWire();
    message.kind = object.kind ?? undefined;
    message.p1ParentIdx = object.p1ParentIdx ?? 0;
    message.p1Group = object.p1Group ?? 0;
    message.p1Idx = object.p1Idx ?? 0;
    message.p2ParentIdx = object.p2ParentIdx ?? 0;
    message.p2Group = object.p2Group ?? 0;
    message.p2Idx = object.p2Idx ?? 0;
    message.name = object.name ?? undefined;
    message.color = object.color ?? undefined;
    message.otherProps = Object.entries(object.otherProps ?? {}).reduce<{ [key: string]: Prop }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Prop.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseWire_OtherPropsEntry(): Wire_OtherPropsEntry {
  return { key: "", value: undefined };
}

export const Wire_OtherPropsEntry: MessageFns<Wire_OtherPropsEntry> = {
  encode(message: Wire_OtherPropsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Prop.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Wire_OtherPropsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWire_OtherPropsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Prop.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Wire_OtherPropsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Prop.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Wire_OtherPropsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Prop.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Wire_OtherPropsEntry>, I>>(base?: I): Wire_OtherPropsEntry {
    return Wire_OtherPropsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Wire_OtherPropsEntry>, I>>(object: I): Wire_OtherPropsEntry {
    const message = createBaseWire_OtherPropsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Prop.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseCamera(): Camera {
  return { x: 0, y: 0, zoom: 0 };
}

export const Camera: MessageFns<Camera> = {
  encode(message: Camera, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    if (message.zoom !== 0) {
      writer.uint32(29).float(message.zoom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Camera {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCamera();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.zoom = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Camera {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      zoom: isSet(object.zoom) ? globalThis.Number(object.zoom) : 0,
    };
  },

  toJSON(message: Camera): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.zoom !== 0) {
      obj.zoom = message.zoom;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Camera>, I>>(base?: I): Camera {
    return Camera.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Camera>, I>>(object: I): Camera {
    const message = createBaseCamera();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.zoom = object.zoom ?? 0;
    return message;
  },
};

function createBaseCircuitMetadata(): CircuitMetadata {
  return { id: "", name: "", desc: "", version: "" };
}

export const CircuitMetadata: MessageFns<CircuitMetadata> = {
  encode(message: CircuitMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.desc !== "") {
      writer.uint32(26).string(message.desc);
    }
    if (message.version !== "") {
      writer.uint32(34).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CircuitMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCircuitMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.desc = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.version = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CircuitMetadata {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      desc: isSet(object.desc) ? globalThis.String(object.desc) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: CircuitMetadata): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.desc !== "") {
      obj.desc = message.desc;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CircuitMetadata>, I>>(base?: I): CircuitMetadata {
    return CircuitMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CircuitMetadata>, I>>(object: I): CircuitMetadata {
    const message = createBaseCircuitMetadata();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.desc = object.desc ?? "";
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseIntegratedCircuitMetadata(): IntegratedCircuitMetadata {
  return { metadata: undefined, displayWidth: 0, displayHeight: 0, portGroups: {}, pins: [] };
}

export const IntegratedCircuitMetadata: MessageFns<IntegratedCircuitMetadata> = {
  encode(message: IntegratedCircuitMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      CircuitMetadata.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    if (message.displayWidth !== 0) {
      writer.uint32(21).float(message.displayWidth);
    }
    if (message.displayHeight !== 0) {
      writer.uint32(29).float(message.displayHeight);
    }
    Object.entries(message.portGroups).forEach(([key, value]) => {
      IntegratedCircuitMetadata_PortGroupsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    for (const v of message.pins) {
      IntegratedCircuitMetadata_Pin.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntegratedCircuitMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntegratedCircuitMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = CircuitMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.displayWidth = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.displayHeight = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = IntegratedCircuitMetadata_PortGroupsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.portGroups[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pins.push(IntegratedCircuitMetadata_Pin.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntegratedCircuitMetadata {
    return {
      metadata: isSet(object.metadata) ? CircuitMetadata.fromJSON(object.metadata) : undefined,
      displayWidth: isSet(object.displayWidth) ? globalThis.Number(object.displayWidth) : 0,
      displayHeight: isSet(object.displayHeight) ? globalThis.Number(object.displayHeight) : 0,
      portGroups: isObject(object.portGroups)
        ? Object.entries(object.portGroups).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      pins: globalThis.Array.isArray(object?.pins)
        ? object.pins.map((e: any) => IntegratedCircuitMetadata_Pin.fromJSON(e))
        : [],
    };
  },

  toJSON(message: IntegratedCircuitMetadata): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = CircuitMetadata.toJSON(message.metadata);
    }
    if (message.displayWidth !== 0) {
      obj.displayWidth = message.displayWidth;
    }
    if (message.displayHeight !== 0) {
      obj.displayHeight = message.displayHeight;
    }
    if (message.portGroups) {
      const entries = Object.entries(message.portGroups);
      if (entries.length > 0) {
        obj.portGroups = {};
        entries.forEach(([k, v]) => {
          obj.portGroups[k] = Math.round(v);
        });
      }
    }
    if (message.pins?.length) {
      obj.pins = message.pins.map((e) => IntegratedCircuitMetadata_Pin.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IntegratedCircuitMetadata>, I>>(base?: I): IntegratedCircuitMetadata {
    return IntegratedCircuitMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IntegratedCircuitMetadata>, I>>(object: I): IntegratedCircuitMetadata {
    const message = createBaseIntegratedCircuitMetadata();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? CircuitMetadata.fromPartial(object.metadata)
      : undefined;
    message.displayWidth = object.displayWidth ?? 0;
    message.displayHeight = object.displayHeight ?? 0;
    message.portGroups = Object.entries(object.portGroups ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    message.pins = object.pins?.map((e) => IntegratedCircuitMetadata_Pin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseIntegratedCircuitMetadata_PortGroupsEntry(): IntegratedCircuitMetadata_PortGroupsEntry {
  return { key: "", value: 0 };
}

export const IntegratedCircuitMetadata_PortGroupsEntry: MessageFns<IntegratedCircuitMetadata_PortGroupsEntry> = {
  encode(message: IntegratedCircuitMetadata_PortGroupsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).uint32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntegratedCircuitMetadata_PortGroupsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntegratedCircuitMetadata_PortGroupsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntegratedCircuitMetadata_PortGroupsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: IntegratedCircuitMetadata_PortGroupsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IntegratedCircuitMetadata_PortGroupsEntry>, I>>(
    base?: I,
  ): IntegratedCircuitMetadata_PortGroupsEntry {
    return IntegratedCircuitMetadata_PortGroupsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IntegratedCircuitMetadata_PortGroupsEntry>, I>>(
    object: I,
  ): IntegratedCircuitMetadata_PortGroupsEntry {
    const message = createBaseIntegratedCircuitMetadata_PortGroupsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseIntegratedCircuitMetadata_Pin(): IntegratedCircuitMetadata_Pin {
  return { internalCompIdx: 0, internalPortIdx: 0, group: 0, name: "", x: 0, y: 0, dx: 0, dy: 0 };
}

export const IntegratedCircuitMetadata_Pin: MessageFns<IntegratedCircuitMetadata_Pin> = {
  encode(message: IntegratedCircuitMetadata_Pin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.internalCompIdx !== 0) {
      writer.uint32(8).uint32(message.internalCompIdx);
    }
    if (message.internalPortIdx !== 0) {
      writer.uint32(16).uint32(message.internalPortIdx);
    }
    if (message.group !== 0) {
      writer.uint32(24).uint32(message.group);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.x !== 0) {
      writer.uint32(45).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(53).float(message.y);
    }
    if (message.dx !== 0) {
      writer.uint32(61).float(message.dx);
    }
    if (message.dy !== 0) {
      writer.uint32(69).float(message.dy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntegratedCircuitMetadata_Pin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntegratedCircuitMetadata_Pin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.internalCompIdx = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.internalPortIdx = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.group = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.y = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.dx = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.dy = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntegratedCircuitMetadata_Pin {
    return {
      internalCompIdx: isSet(object.internalCompIdx) ? globalThis.Number(object.internalCompIdx) : 0,
      internalPortIdx: isSet(object.internalPortIdx) ? globalThis.Number(object.internalPortIdx) : 0,
      group: isSet(object.group) ? globalThis.Number(object.group) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      dx: isSet(object.dx) ? globalThis.Number(object.dx) : 0,
      dy: isSet(object.dy) ? globalThis.Number(object.dy) : 0,
    };
  },

  toJSON(message: IntegratedCircuitMetadata_Pin): unknown {
    const obj: any = {};
    if (message.internalCompIdx !== 0) {
      obj.internalCompIdx = Math.round(message.internalCompIdx);
    }
    if (message.internalPortIdx !== 0) {
      obj.internalPortIdx = Math.round(message.internalPortIdx);
    }
    if (message.group !== 0) {
      obj.group = Math.round(message.group);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.dx !== 0) {
      obj.dx = message.dx;
    }
    if (message.dy !== 0) {
      obj.dy = message.dy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IntegratedCircuitMetadata_Pin>, I>>(base?: I): IntegratedCircuitMetadata_Pin {
    return IntegratedCircuitMetadata_Pin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IntegratedCircuitMetadata_Pin>, I>>(
    object: I,
  ): IntegratedCircuitMetadata_Pin {
    const message = createBaseIntegratedCircuitMetadata_Pin();
    message.internalCompIdx = object.internalCompIdx ?? 0;
    message.internalPortIdx = object.internalPortIdx ?? 0;
    message.group = object.group ?? 0;
    message.name = object.name ?? "";
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.dx = object.dx ?? 0;
    message.dy = object.dy ?? 0;
    return message;
  },
};

function createBaseIntegratedCircuit(): IntegratedCircuit {
  return { metadata: undefined, components: [], wires: [] };
}

export const IntegratedCircuit: MessageFns<IntegratedCircuit> = {
  encode(message: IntegratedCircuit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      IntegratedCircuitMetadata.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    for (const v of message.components) {
      Component.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.wires) {
      Wire.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntegratedCircuit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntegratedCircuit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = IntegratedCircuitMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.components.push(Component.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.wires.push(Wire.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntegratedCircuit {
    return {
      metadata: isSet(object.metadata) ? IntegratedCircuitMetadata.fromJSON(object.metadata) : undefined,
      components: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => Component.fromJSON(e))
        : [],
      wires: globalThis.Array.isArray(object?.wires) ? object.wires.map((e: any) => Wire.fromJSON(e)) : [],
    };
  },

  toJSON(message: IntegratedCircuit): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = IntegratedCircuitMetadata.toJSON(message.metadata);
    }
    if (message.components?.length) {
      obj.components = message.components.map((e) => Component.toJSON(e));
    }
    if (message.wires?.length) {
      obj.wires = message.wires.map((e) => Wire.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IntegratedCircuit>, I>>(base?: I): IntegratedCircuit {
    return IntegratedCircuit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IntegratedCircuit>, I>>(object: I): IntegratedCircuit {
    const message = createBaseIntegratedCircuit();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? IntegratedCircuitMetadata.fromPartial(object.metadata)
      : undefined;
    message.components = object.components?.map((e) => Component.fromPartial(e)) || [];
    message.wires = object.wires?.map((e) => Wire.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCircuit(): Circuit {
  return { metadata: undefined, camera: undefined, ics: [], components: [], wires: [] };
}

export const Circuit: MessageFns<Circuit> = {
  encode(message: Circuit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      CircuitMetadata.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    if (message.camera !== undefined) {
      Camera.encode(message.camera, writer.uint32(18).fork()).join();
    }
    for (const v of message.ics) {
      IntegratedCircuit.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.components) {
      Component.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.wires) {
      Wire.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Circuit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCircuit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = CircuitMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.camera = Camera.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ics.push(IntegratedCircuit.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.components.push(Component.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.wires.push(Wire.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Circuit {
    return {
      metadata: isSet(object.metadata) ? CircuitMetadata.fromJSON(object.metadata) : undefined,
      camera: isSet(object.camera) ? Camera.fromJSON(object.camera) : undefined,
      ics: globalThis.Array.isArray(object?.ics) ? object.ics.map((e: any) => IntegratedCircuit.fromJSON(e)) : [],
      components: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => Component.fromJSON(e))
        : [],
      wires: globalThis.Array.isArray(object?.wires) ? object.wires.map((e: any) => Wire.fromJSON(e)) : [],
    };
  },

  toJSON(message: Circuit): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = CircuitMetadata.toJSON(message.metadata);
    }
    if (message.camera !== undefined) {
      obj.camera = Camera.toJSON(message.camera);
    }
    if (message.ics?.length) {
      obj.ics = message.ics.map((e) => IntegratedCircuit.toJSON(e));
    }
    if (message.components?.length) {
      obj.components = message.components.map((e) => Component.toJSON(e));
    }
    if (message.wires?.length) {
      obj.wires = message.wires.map((e) => Wire.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Circuit>, I>>(base?: I): Circuit {
    return Circuit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Circuit>, I>>(object: I): Circuit {
    const message = createBaseCircuit();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? CircuitMetadata.fromPartial(object.metadata)
      : undefined;
    message.camera = (object.camera !== undefined && object.camera !== null)
      ? Camera.fromPartial(object.camera)
      : undefined;
    message.ics = object.ics?.map((e) => IntegratedCircuit.fromPartial(e)) || [];
    message.components = object.components?.map((e) => Component.fromPartial(e)) || [];
    message.wires = object.wires?.map((e) => Wire.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
