// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.30.2
// source: src/projects/shared/site/src/proto/Circuit.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "";

export interface Prop {
  intVal?: number | undefined;
  floatVal?: number | undefined;
  strVal?: string | undefined;
  boolVal?: boolean | undefined;
}

export interface Component {
  id: Uint8Array;
  kind: string;
  props: { [key: string]: Prop };
}

export interface Component_PropsEntry {
  key: string;
  value: Prop | undefined;
}

export interface Wire {
  id: Uint8Array;
  kind: string;
  props: { [key: string]: Prop };
  p1: Uint8Array;
  p2: Uint8Array;
}

export interface Wire_PropsEntry {
  key: string;
  value: Prop | undefined;
}

export interface Port {
  id: Uint8Array;
  kind: string;
  props: { [key: string]: Prop };
  parent: Uint8Array;
  group: string;
  index: number;
}

export interface Port_PropsEntry {
  key: string;
  value: Prop | undefined;
}

export interface Camera {
  x: number;
  y: number;
  zoom: number;
}

export interface CircuitMetadata {
  id: Uint8Array;
  name: string;
  desc: string;
  thumb: string;
  version: string;
}

export interface IntegratedCircuitMetadata {
  metadata: CircuitMetadata | undefined;
  displayWidth: number;
  displayHeight: number;
  pins: IntegratedCircuitMetadata_Pin[];
}

export interface IntegratedCircuitMetadata_Pin {
  id: Uint8Array;
  group: string;
  name: string;
  x: number;
  y: number;
  dx: number;
  dy: number;
}

export interface IntegratedCircuit {
  metadata: IntegratedCircuitMetadata | undefined;
  components: Component[];
  wires: Wire[];
  ports: Port[];
}

export interface Circuit {
  metadata: CircuitMetadata | undefined;
  camera: Camera | undefined;
  ics: IntegratedCircuit[];
  components: Component[];
  wires: Wire[];
  ports: Port[];
}

function createBaseProp(): Prop {
  return { intVal: undefined, floatVal: undefined, strVal: undefined, boolVal: undefined };
}

export const Prop: MessageFns<Prop> = {
  encode(message: Prop, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.intVal !== undefined) {
      writer.uint32(8).int32(message.intVal);
    }
    if (message.floatVal !== undefined) {
      writer.uint32(21).float(message.floatVal);
    }
    if (message.strVal !== undefined) {
      writer.uint32(26).string(message.strVal);
    }
    if (message.boolVal !== undefined) {
      writer.uint32(32).bool(message.boolVal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Prop {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.intVal = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.floatVal = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.strVal = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.boolVal = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Prop {
    return {
      intVal: isSet(object.intVal) ? globalThis.Number(object.intVal) : undefined,
      floatVal: isSet(object.floatVal) ? globalThis.Number(object.floatVal) : undefined,
      strVal: isSet(object.strVal) ? globalThis.String(object.strVal) : undefined,
      boolVal: isSet(object.boolVal) ? globalThis.Boolean(object.boolVal) : undefined,
    };
  },

  toJSON(message: Prop): unknown {
    const obj: any = {};
    if (message.intVal !== undefined) {
      obj.intVal = Math.round(message.intVal);
    }
    if (message.floatVal !== undefined) {
      obj.floatVal = message.floatVal;
    }
    if (message.strVal !== undefined) {
      obj.strVal = message.strVal;
    }
    if (message.boolVal !== undefined) {
      obj.boolVal = message.boolVal;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Prop>, I>>(base?: I): Prop {
    return Prop.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Prop>, I>>(object: I): Prop {
    const message = createBaseProp();
    message.intVal = object.intVal ?? undefined;
    message.floatVal = object.floatVal ?? undefined;
    message.strVal = object.strVal ?? undefined;
    message.boolVal = object.boolVal ?? undefined;
    return message;
  },
};

function createBaseComponent(): Component {
  return { id: new Uint8Array(0), kind: "", props: {} };
}

export const Component: MessageFns<Component> = {
  encode(message: Component, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    Object.entries(message.props).forEach(([key, value]) => {
      Component_PropsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Component {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComponent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.kind = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = Component_PropsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.props[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Component {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      props: isObject(object.props)
        ? Object.entries(object.props).reduce<{ [key: string]: Prop }>((acc, [key, value]) => {
          acc[key] = Prop.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Component): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.props) {
      const entries = Object.entries(message.props);
      if (entries.length > 0) {
        obj.props = {};
        entries.forEach(([k, v]) => {
          obj.props[k] = Prop.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Component>, I>>(base?: I): Component {
    return Component.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Component>, I>>(object: I): Component {
    const message = createBaseComponent();
    message.id = object.id ?? new Uint8Array(0);
    message.kind = object.kind ?? "";
    message.props = Object.entries(object.props ?? {}).reduce<{ [key: string]: Prop }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Prop.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseComponent_PropsEntry(): Component_PropsEntry {
  return { key: "", value: undefined };
}

export const Component_PropsEntry: MessageFns<Component_PropsEntry> = {
  encode(message: Component_PropsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Prop.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Component_PropsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComponent_PropsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Prop.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Component_PropsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Prop.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Component_PropsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Prop.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Component_PropsEntry>, I>>(base?: I): Component_PropsEntry {
    return Component_PropsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Component_PropsEntry>, I>>(object: I): Component_PropsEntry {
    const message = createBaseComponent_PropsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Prop.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseWire(): Wire {
  return { id: new Uint8Array(0), kind: "", props: {}, p1: new Uint8Array(0), p2: new Uint8Array(0) };
}

export const Wire: MessageFns<Wire> = {
  encode(message: Wire, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    Object.entries(message.props).forEach(([key, value]) => {
      Wire_PropsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.p1.length !== 0) {
      writer.uint32(34).bytes(message.p1);
    }
    if (message.p2.length !== 0) {
      writer.uint32(42).bytes(message.p2);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Wire {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWire();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.kind = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = Wire_PropsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.props[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.p1 = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.p2 = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Wire {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      props: isObject(object.props)
        ? Object.entries(object.props).reduce<{ [key: string]: Prop }>((acc, [key, value]) => {
          acc[key] = Prop.fromJSON(value);
          return acc;
        }, {})
        : {},
      p1: isSet(object.p1) ? bytesFromBase64(object.p1) : new Uint8Array(0),
      p2: isSet(object.p2) ? bytesFromBase64(object.p2) : new Uint8Array(0),
    };
  },

  toJSON(message: Wire): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.props) {
      const entries = Object.entries(message.props);
      if (entries.length > 0) {
        obj.props = {};
        entries.forEach(([k, v]) => {
          obj.props[k] = Prop.toJSON(v);
        });
      }
    }
    if (message.p1.length !== 0) {
      obj.p1 = base64FromBytes(message.p1);
    }
    if (message.p2.length !== 0) {
      obj.p2 = base64FromBytes(message.p2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Wire>, I>>(base?: I): Wire {
    return Wire.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Wire>, I>>(object: I): Wire {
    const message = createBaseWire();
    message.id = object.id ?? new Uint8Array(0);
    message.kind = object.kind ?? "";
    message.props = Object.entries(object.props ?? {}).reduce<{ [key: string]: Prop }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Prop.fromPartial(value);
      }
      return acc;
    }, {});
    message.p1 = object.p1 ?? new Uint8Array(0);
    message.p2 = object.p2 ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWire_PropsEntry(): Wire_PropsEntry {
  return { key: "", value: undefined };
}

export const Wire_PropsEntry: MessageFns<Wire_PropsEntry> = {
  encode(message: Wire_PropsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Prop.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Wire_PropsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWire_PropsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Prop.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Wire_PropsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Prop.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Wire_PropsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Prop.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Wire_PropsEntry>, I>>(base?: I): Wire_PropsEntry {
    return Wire_PropsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Wire_PropsEntry>, I>>(object: I): Wire_PropsEntry {
    const message = createBaseWire_PropsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Prop.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBasePort(): Port {
  return { id: new Uint8Array(0), kind: "", props: {}, parent: new Uint8Array(0), group: "", index: 0 };
}

export const Port: MessageFns<Port> = {
  encode(message: Port, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    Object.entries(message.props).forEach(([key, value]) => {
      Port_PropsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.parent.length !== 0) {
      writer.uint32(34).bytes(message.parent);
    }
    if (message.group !== "") {
      writer.uint32(42).string(message.group);
    }
    if (message.index !== 0) {
      writer.uint32(48).int32(message.index);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Port {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePort();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.kind = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = Port_PropsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.props[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parent = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.group = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.index = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Port {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      props: isObject(object.props)
        ? Object.entries(object.props).reduce<{ [key: string]: Prop }>((acc, [key, value]) => {
          acc[key] = Prop.fromJSON(value);
          return acc;
        }, {})
        : {},
      parent: isSet(object.parent) ? bytesFromBase64(object.parent) : new Uint8Array(0),
      group: isSet(object.group) ? globalThis.String(object.group) : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
    };
  },

  toJSON(message: Port): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.props) {
      const entries = Object.entries(message.props);
      if (entries.length > 0) {
        obj.props = {};
        entries.forEach(([k, v]) => {
          obj.props[k] = Prop.toJSON(v);
        });
      }
    }
    if (message.parent.length !== 0) {
      obj.parent = base64FromBytes(message.parent);
    }
    if (message.group !== "") {
      obj.group = message.group;
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Port>, I>>(base?: I): Port {
    return Port.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Port>, I>>(object: I): Port {
    const message = createBasePort();
    message.id = object.id ?? new Uint8Array(0);
    message.kind = object.kind ?? "";
    message.props = Object.entries(object.props ?? {}).reduce<{ [key: string]: Prop }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Prop.fromPartial(value);
      }
      return acc;
    }, {});
    message.parent = object.parent ?? new Uint8Array(0);
    message.group = object.group ?? "";
    message.index = object.index ?? 0;
    return message;
  },
};

function createBasePort_PropsEntry(): Port_PropsEntry {
  return { key: "", value: undefined };
}

export const Port_PropsEntry: MessageFns<Port_PropsEntry> = {
  encode(message: Port_PropsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Prop.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Port_PropsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePort_PropsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Prop.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Port_PropsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Prop.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Port_PropsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Prop.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Port_PropsEntry>, I>>(base?: I): Port_PropsEntry {
    return Port_PropsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Port_PropsEntry>, I>>(object: I): Port_PropsEntry {
    const message = createBasePort_PropsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Prop.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseCamera(): Camera {
  return { x: 0, y: 0, zoom: 0 };
}

export const Camera: MessageFns<Camera> = {
  encode(message: Camera, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    if (message.zoom !== 0) {
      writer.uint32(29).float(message.zoom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Camera {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCamera();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.zoom = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Camera {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      zoom: isSet(object.zoom) ? globalThis.Number(object.zoom) : 0,
    };
  },

  toJSON(message: Camera): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.zoom !== 0) {
      obj.zoom = message.zoom;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Camera>, I>>(base?: I): Camera {
    return Camera.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Camera>, I>>(object: I): Camera {
    const message = createBaseCamera();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.zoom = object.zoom ?? 0;
    return message;
  },
};

function createBaseCircuitMetadata(): CircuitMetadata {
  return { id: new Uint8Array(0), name: "", desc: "", thumb: "", version: "" };
}

export const CircuitMetadata: MessageFns<CircuitMetadata> = {
  encode(message: CircuitMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.desc !== "") {
      writer.uint32(26).string(message.desc);
    }
    if (message.thumb !== "") {
      writer.uint32(34).string(message.thumb);
    }
    if (message.version !== "") {
      writer.uint32(42).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CircuitMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCircuitMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.desc = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.thumb = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.version = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CircuitMetadata {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      desc: isSet(object.desc) ? globalThis.String(object.desc) : "",
      thumb: isSet(object.thumb) ? globalThis.String(object.thumb) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: CircuitMetadata): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.desc !== "") {
      obj.desc = message.desc;
    }
    if (message.thumb !== "") {
      obj.thumb = message.thumb;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CircuitMetadata>, I>>(base?: I): CircuitMetadata {
    return CircuitMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CircuitMetadata>, I>>(object: I): CircuitMetadata {
    const message = createBaseCircuitMetadata();
    message.id = object.id ?? new Uint8Array(0);
    message.name = object.name ?? "";
    message.desc = object.desc ?? "";
    message.thumb = object.thumb ?? "";
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseIntegratedCircuitMetadata(): IntegratedCircuitMetadata {
  return { metadata: undefined, displayWidth: 0, displayHeight: 0, pins: [] };
}

export const IntegratedCircuitMetadata: MessageFns<IntegratedCircuitMetadata> = {
  encode(message: IntegratedCircuitMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      CircuitMetadata.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    if (message.displayWidth !== 0) {
      writer.uint32(21).float(message.displayWidth);
    }
    if (message.displayHeight !== 0) {
      writer.uint32(29).float(message.displayHeight);
    }
    for (const v of message.pins) {
      IntegratedCircuitMetadata_Pin.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntegratedCircuitMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntegratedCircuitMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = CircuitMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.displayWidth = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.displayHeight = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pins.push(IntegratedCircuitMetadata_Pin.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntegratedCircuitMetadata {
    return {
      metadata: isSet(object.metadata) ? CircuitMetadata.fromJSON(object.metadata) : undefined,
      displayWidth: isSet(object.displayWidth) ? globalThis.Number(object.displayWidth) : 0,
      displayHeight: isSet(object.displayHeight) ? globalThis.Number(object.displayHeight) : 0,
      pins: globalThis.Array.isArray(object?.pins)
        ? object.pins.map((e: any) => IntegratedCircuitMetadata_Pin.fromJSON(e))
        : [],
    };
  },

  toJSON(message: IntegratedCircuitMetadata): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = CircuitMetadata.toJSON(message.metadata);
    }
    if (message.displayWidth !== 0) {
      obj.displayWidth = message.displayWidth;
    }
    if (message.displayHeight !== 0) {
      obj.displayHeight = message.displayHeight;
    }
    if (message.pins?.length) {
      obj.pins = message.pins.map((e) => IntegratedCircuitMetadata_Pin.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IntegratedCircuitMetadata>, I>>(base?: I): IntegratedCircuitMetadata {
    return IntegratedCircuitMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IntegratedCircuitMetadata>, I>>(object: I): IntegratedCircuitMetadata {
    const message = createBaseIntegratedCircuitMetadata();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? CircuitMetadata.fromPartial(object.metadata)
      : undefined;
    message.displayWidth = object.displayWidth ?? 0;
    message.displayHeight = object.displayHeight ?? 0;
    message.pins = object.pins?.map((e) => IntegratedCircuitMetadata_Pin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseIntegratedCircuitMetadata_Pin(): IntegratedCircuitMetadata_Pin {
  return { id: new Uint8Array(0), group: "", name: "", x: 0, y: 0, dx: 0, dy: 0 };
}

export const IntegratedCircuitMetadata_Pin: MessageFns<IntegratedCircuitMetadata_Pin> = {
  encode(message: IntegratedCircuitMetadata_Pin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (message.group !== "") {
      writer.uint32(18).string(message.group);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.x !== 0) {
      writer.uint32(37).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(45).float(message.y);
    }
    if (message.dx !== 0) {
      writer.uint32(53).float(message.dx);
    }
    if (message.dy !== 0) {
      writer.uint32(61).float(message.dy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntegratedCircuitMetadata_Pin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntegratedCircuitMetadata_Pin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.group = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.y = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.dx = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.dy = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntegratedCircuitMetadata_Pin {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      group: isSet(object.group) ? globalThis.String(object.group) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      dx: isSet(object.dx) ? globalThis.Number(object.dx) : 0,
      dy: isSet(object.dy) ? globalThis.Number(object.dy) : 0,
    };
  },

  toJSON(message: IntegratedCircuitMetadata_Pin): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.group !== "") {
      obj.group = message.group;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.dx !== 0) {
      obj.dx = message.dx;
    }
    if (message.dy !== 0) {
      obj.dy = message.dy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IntegratedCircuitMetadata_Pin>, I>>(base?: I): IntegratedCircuitMetadata_Pin {
    return IntegratedCircuitMetadata_Pin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IntegratedCircuitMetadata_Pin>, I>>(
    object: I,
  ): IntegratedCircuitMetadata_Pin {
    const message = createBaseIntegratedCircuitMetadata_Pin();
    message.id = object.id ?? new Uint8Array(0);
    message.group = object.group ?? "";
    message.name = object.name ?? "";
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.dx = object.dx ?? 0;
    message.dy = object.dy ?? 0;
    return message;
  },
};

function createBaseIntegratedCircuit(): IntegratedCircuit {
  return { metadata: undefined, components: [], wires: [], ports: [] };
}

export const IntegratedCircuit: MessageFns<IntegratedCircuit> = {
  encode(message: IntegratedCircuit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      IntegratedCircuitMetadata.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    for (const v of message.components) {
      Component.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.wires) {
      Wire.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.ports) {
      Port.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntegratedCircuit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntegratedCircuit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = IntegratedCircuitMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.components.push(Component.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.wires.push(Wire.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ports.push(Port.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntegratedCircuit {
    return {
      metadata: isSet(object.metadata) ? IntegratedCircuitMetadata.fromJSON(object.metadata) : undefined,
      components: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => Component.fromJSON(e))
        : [],
      wires: globalThis.Array.isArray(object?.wires) ? object.wires.map((e: any) => Wire.fromJSON(e)) : [],
      ports: globalThis.Array.isArray(object?.ports) ? object.ports.map((e: any) => Port.fromJSON(e)) : [],
    };
  },

  toJSON(message: IntegratedCircuit): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = IntegratedCircuitMetadata.toJSON(message.metadata);
    }
    if (message.components?.length) {
      obj.components = message.components.map((e) => Component.toJSON(e));
    }
    if (message.wires?.length) {
      obj.wires = message.wires.map((e) => Wire.toJSON(e));
    }
    if (message.ports?.length) {
      obj.ports = message.ports.map((e) => Port.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IntegratedCircuit>, I>>(base?: I): IntegratedCircuit {
    return IntegratedCircuit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IntegratedCircuit>, I>>(object: I): IntegratedCircuit {
    const message = createBaseIntegratedCircuit();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? IntegratedCircuitMetadata.fromPartial(object.metadata)
      : undefined;
    message.components = object.components?.map((e) => Component.fromPartial(e)) || [];
    message.wires = object.wires?.map((e) => Wire.fromPartial(e)) || [];
    message.ports = object.ports?.map((e) => Port.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCircuit(): Circuit {
  return { metadata: undefined, camera: undefined, ics: [], components: [], wires: [], ports: [] };
}

export const Circuit: MessageFns<Circuit> = {
  encode(message: Circuit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      CircuitMetadata.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    if (message.camera !== undefined) {
      Camera.encode(message.camera, writer.uint32(18).fork()).join();
    }
    for (const v of message.ics) {
      IntegratedCircuit.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.components) {
      Component.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.wires) {
      Wire.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.ports) {
      Port.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Circuit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCircuit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = CircuitMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.camera = Camera.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ics.push(IntegratedCircuit.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.components.push(Component.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.wires.push(Wire.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.ports.push(Port.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Circuit {
    return {
      metadata: isSet(object.metadata) ? CircuitMetadata.fromJSON(object.metadata) : undefined,
      camera: isSet(object.camera) ? Camera.fromJSON(object.camera) : undefined,
      ics: globalThis.Array.isArray(object?.ics) ? object.ics.map((e: any) => IntegratedCircuit.fromJSON(e)) : [],
      components: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => Component.fromJSON(e))
        : [],
      wires: globalThis.Array.isArray(object?.wires) ? object.wires.map((e: any) => Wire.fromJSON(e)) : [],
      ports: globalThis.Array.isArray(object?.ports) ? object.ports.map((e: any) => Port.fromJSON(e)) : [],
    };
  },

  toJSON(message: Circuit): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = CircuitMetadata.toJSON(message.metadata);
    }
    if (message.camera !== undefined) {
      obj.camera = Camera.toJSON(message.camera);
    }
    if (message.ics?.length) {
      obj.ics = message.ics.map((e) => IntegratedCircuit.toJSON(e));
    }
    if (message.components?.length) {
      obj.components = message.components.map((e) => Component.toJSON(e));
    }
    if (message.wires?.length) {
      obj.wires = message.wires.map((e) => Wire.toJSON(e));
    }
    if (message.ports?.length) {
      obj.ports = message.ports.map((e) => Port.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Circuit>, I>>(base?: I): Circuit {
    return Circuit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Circuit>, I>>(object: I): Circuit {
    const message = createBaseCircuit();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? CircuitMetadata.fromPartial(object.metadata)
      : undefined;
    message.camera = (object.camera !== undefined && object.camera !== null)
      ? Camera.fromPartial(object.camera)
      : undefined;
    message.ics = object.ics?.map((e) => IntegratedCircuit.fromPartial(e)) || [];
    message.components = object.components?.map((e) => Component.fromPartial(e)) || [];
    message.wires = object.wires?.map((e) => Wire.fromPartial(e)) || [];
    message.ports = object.ports?.map((e) => Port.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
